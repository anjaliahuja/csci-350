Title:  Writeup for Project 2, Fall 2015 CSCI 350
 Date:  10/20/2015
 Group:
 Anjali Ahuja 	ahujaa@usc.edu
 Anne Kao 		annekao@usc.edu
 Bernard Xie	bernardx@usc.edu


I. REQUIREMENTS:
	+ Part 1: 
	Implement system calls and exception handling for acquire, release, wait, signal, broadcast. As well as- CreateLock, DestroyLock, CreateCondition, DestroyCondition, and Exit Fork and Yield. 
	Implement process table to maintain mapping of processes, threads to the correct correspnding address spae.
	Implement a testsuite of user programs to demonstrate correctness of system calls.
	+ Part 2:
	Implement multiprogramming and complete implementation of Exec and Fork System calls. Design a test that shows correct implementation of exec and fork.
	+ Part 3:
	Run project 1 passport simulation using new syscalls that were written


II. ASSUMPTIONS:
	+ Sys calls will allow project 1 to function in the following way:
	-Up to 5 of each type of clerk, 50 customers, 1 manager and 10 senators can be simulated and properly synchronized without the program crashing and with the correct sharing of locks, condition variables and monitor variables.
	-Customers enter the passport office with a completed application
	-Actions written in the assignment requirements are simulated through the proper implementation of waking up threads, acquiring/releasing locks and using print statements to simualte the exchange of data. 
	-When a customer gets sent to the "back of the line", they must start over the process of looking for the shortest line.
	-For PassportClerk & Cashier, there is no official verification of whether they went to the ApplicationClerk or PictureClerk.  Instead, there is a small random chance that the PassportClerk/Cashier tells them to go to the back of the line.  This is because the way our clerks were implemented were that Customers can not move onto the next clerk without a Signal from their current clerk that they can leave. 
	-All Clerks and the Cashier have bribe lines.
	- When a customer shows up to choose a line, it first looks through all lines to see if it can get into one of those lines that has a clerk not on break, if it can't find one of those lines then it goes to the first on break clerk.
	-Customers can wait on lines that are on break.


	
III. DESIGN:
	i. Part 1
		Locks:
			We use a lockTable in order to keep track of the locks we have in a process.  There is a lockTableLock that is used so that only one Syscall can access the lockTable at a time to modify it.  We acquire this lock at the beginning of the syscall and release it before the return.
			We also created a kernelLock class that will contain the lock object itself, an address space, lockCounter, which is used to keep track of the number of threads using the lock, and an isToBeDeleted boolean that will be used in destroy/release.
			CreateLock_Syscall: The first part of the function handles extracting the name for the lock.  There is also an error check to ensure that the table has locks available for creation.  After that a new lock is created. A kernelLock is also created with it's lock set to the new lock, the address space set to the currentThread's adress space, isToBeDeleted to false, and lockCounter to 0.  Then the kernelLock is placed in the lock table and the index is recorded.  If it's -1, that means there was no space left in the lock table to create the lock.  Next, the processTable is modified so that we can associate a process with this lock.  The index is then returned to the user program.
			Acquire_Syscall: An index is passed into the Get function for the lockTable in order to find the proper lock to acquire.  If the lock is null, that means that the lock doesn't exist.  If the lock does not belong to the same process as thread creator, it will also throw an error.  If the lock can be acquired, then we increment the lockCounter and return the index.
			Release_Syscall: An index is passed into the Get function for the lockTable in order to find the proper lock to release.  If the lock is null, that means that the lock doesn't exist.  If the lock does not belong to the same process as thread creator, it will also throw an error.  If the lock can be released, then we decrement the lockCounter.  Next we check whether or not the lock should be deleted if the kernelLock's isToBeDeleted was set to true and whether or not the lock has any other threads that have acquired it.  If so, the lock is deleted and the processTable must be updated to disassociate the process and the lock.  After, the index is returned.
			DestroyLock_Syscall: An index is passed into the Get function for the lockTable in order to find the proper lock to destroy.  If the lock is null, that means that the lock doesn't exist.  If the lock does not belong to the same process as thread creator, it will also throw an error.  First we check if the lock is busy.  If it's not then the lock can be removed from the lockTable and then deleted.  If it is busy, then the kernelLock's isToBeDeleted is set to true, so that when the lock becomes free and has no threads using it, it will be destroyed (handled in release).  The processTable must be updated to disassociate the process and the lock.  After, the index is returned.
		Conditions:
			We use a CVTable in order to keep track of the CVs we have in a process.  There is a CVTableLock that is used so that only one Syscall can access the CVTable at a time to modify it.  We acquire this lock at the beginning of the syscall and release it before the return.
			We also created a kernelCV class that will contain the CV object itself, an address space, cvCounter, which is used to keep track of the number of threads using the CV, and an isToBeDeleted boolean that will be used in destroy/wait.
			CreateCV_Syscall: The first part of the function handles extracting the name for the lock.  There is also an error check to ensure that the table has CVs available for creation.  After that a new CV is created. A kernelCV is also created with it's CV set to the new CV, the address space set to the currentThread's adress space, isToBeDeleted to false, and cvCounter to 0.  Then the kernelCV is placed in the cv table and the index is recorded.  If it's -1, that means there was no space left in the cv table to create the cv.  Next, the processTable is modified so that we can associate a process with this cv.  
			Wait_Syscall: An index is passed into the Get function for the lockTable in order to find the proper lock to use for wait.  If the lock is null, that means that the lock doesn't exist.  If the lock does not belong to the same process as thread creator, it will also throw an error.  The same checks occur for the index passed in for the CV.  Then we call wait on the kernelCV's condition.  After the cv wakes up, it will check whether it needs to be deleted or not using the toBeDeleted bool and checking how many other threads are waiting using the cvCounter. If so, the kernelCV will be removed from the CVTable and get deleted.  The process table gets updated to disassociate the cv with the process.
			Signal_Syscall: An index is passed into the Get function for the lockTable in order to find the proper lock to use for wait.  If the lock is null, that means that the lock doesn't exist.  If the lock does not belong to the same process as thread creator, it will also throw an error.  The same checks occur for the index passed in for the CV.  Then signal is called on the kernelCV. The cvCounter gets decremented since one less thread is waiting and the index is returned.
			Broadcast_Syscall: An index is passed into the Get function for the lockTable in order to find the proper lock to use for wait.  If the lock is null, that means that the lock doesn't exist.  If the lock does not belong to the same process as thread creator, it will also throw an error.  The same checks occur for the index passed in for the CV.  Then broadcast is called on the kernelCV. The cvCounter gets set to 0 since all threads waiting will be woken up and the index is returned.
			DestroyCV_Syscall: An index is passed into the Get function for the CVTable in order to find the proper cv to destroy.  If the cv is null, that means that the cv doesn't exist.  If the cv does not belong to the same process as thread creator, it will also throw an error.  First we check if the cv has threads waiting on it.  If not then the cv can be removed from the cvTable and then deleted.  If it is busy, then the kernelCV's isToBeDeleted is set to true, so that when the cv has no waiting threads, it will be destroyed (handled in wait).  The processTable must be updated to disassociate the process and the cv.  After, the index is returned.
	ii. Part 2

		Fork:
			The Fork sys call takes in a user program's function pointer, creates a new thread and allocates 8 new stack pages for that thread by calling AllocateStack in the addres space class. AllocateStack function does the page table translation, copying all values to a new page table that has 8 more pages than the old page table. The stack registers are returned that has the start of stack and last VP of stack for the thread forked, which is then passed to internal_fork to actually fork the thread. All threads in the same process have the same address space, tracked using the process table. To allocate a new thread, the address space is matched with the address space of the processor, and the numThreads variable for that process is incremented. A process lock is used to update the process table and prevent race conitions when multiple threads are being forked in the same process.

		Exec:
			Exec takes in a filename and size and executes a new process. To do this, it first makes a new address space for the process, then forks a new thread to start that process. When the process is created, it is added to the process table and the thread forked is added to that process in the table. 

		Exit: 
			Exit has 3 cases. 
			Case 1 checks if the thread has called exit in the process but its not the last thread in the process. In this case, 8 pages of stack are freed for that process and numThreads for the process is decremented.
			Case 2 checks if the thread is the last executing thread in the last process, so the ready queue would be empty. If this is the case, the exit syscall clears the pageTable pages that have a valid bit set to true, then calls interruptHalt to stop all processes. 
			Case 3 checks if the thread is the last thread in process but not the last process running. If this is the case, exit reclaims all memory, claiming stack pages, Cvs and Locks used by that process. To do this, it calls the DestroyCV_Syscall and the DestroyLock_Syscall so that each lock and cv is checked before it is deleted. The end of exit calls currentThread->Finish. 

		Other syscalls implemented:

		Printf: 
			The printf syscall takes in a virtual address, length and int, then parses the inputs to print out a string with up to 3, 3 digit numbers. It checks for %d, similar to a regular printf statement, then parses out the ints by doing decimal shifts of 3 bits for the input. 

		Rand:
			The rand syscall works just like a C++ rand syscall, taking in 2 inputs, a range and offset and returning the random number in range + offset entered. 


		To keep track of process tables, we used a processTable and processLock. Each time exec was called, the process table was updated with the new process and a thread was added to that process. Every time a syscall is called, the process is found in the process table and the variables associated with it are modified. Before modifying the variables, we use the processLock to prevent race conditions. The process struct has a set of bools of CVs and Locks to check whether they are being used, a counter for threads and counters for numLocks and numCVs. When exit is called, the proper variables are modified and updated for the correct process in the process table. 

IV. IMPLEMENTATION

	i. Files Modified
	../code/threads/synch.h
	../code/threads/synch.cc
	../code/userprog/exception.cc
	../code/threads/system.h
	../code/threads/system.cc
	../code/userprog/addrspace.h
	../code/userprog/addrspace.cc
	../code/userprog/syscall.h
	../code/test/start.s
	../code/test/testfiles.c
	../code/threads/thread.h
	../code/threads/threadtest.cc
	../code/userprog/table.h
	../code/machine/machine.h
	../code/Makefile

	ii. Files added
	GROUPNAME
	WRITEUP
	../code/test/testexit.c
	../code/test/testexitprogram.c
	../code/test/testprint.c
	../code/test/passportstart.c
	../code/test/passportsim.c
	../code/test/passporttest1.c
	../code/test/passporttest2.c
	../code/test/passporttest3.c
	../code/test/passporttest4.c
	../code/test/passporttest5.c
	../code/test/passporttest6.c
	../code/test/passporttest7.c
	../code/test/lock_cv_test1.c
	../code/test/lock_cv_test2.c
	../code/test/lock_cv_test3.c
	../code/test/lock_cv_test4.c
	../code/test/lock_cv_test5.c

	iii. Data Structures added, file they were added to
	In ../code/threads/system.h
		extern Lock* availMem; 
		extern BitMap* bitMap; 

		#define NumLocks 10000
		#define NumCVs 10000
		#define NumProcesses 20

		extern Table* lockTable;
		extern Lock* lockTableLock;

		extern Table* CVTable;
		extern Lock* CVTableLock;

		extern Table* processTable;
		extern Lock* processLock;

		struct kernelLock {
			Lock* lock;
			AddrSpace* addressSpace;
			bool toBeDeleted;
			int lockCounter;
		};

		struct kernelCV{
			Condition* condition;
			AddrSpace* addressSpace;
			bool toBeDeleted;
			int cvCounter;
		};

		struct kernelProcess{
			kernelProcess(){
				addressSpace = currentThread->space; 
				numThreads = 0;
			}
			~kernelProcess(){
				
			}

			AddrSpace* addressSpace;
			int numThreads;
			
		};

	iv. Data structures modified and file they were added to
		class AddressSpace{
			//Modified Address Space Constructor
			//Init Registers
			//Allocate Stack
		}

	v. Functions added and in which file
	In addrspace.cc:
	int* AddrSpace::AllocateStack();

	In exception.cc:
	int CreateCV_Syscall(int vaddr, int size);
	int DestroyCV_Syscall(int index);
	int Wait_Syscall(int lockINdex, int CVIndex);
	int Signal_Syscall(int lockIndex, int CVIndex);
	int Broadcast_Syscall(int lockIndex, int CVIndex);
	int CreateLock_Syscall(unsigned int vaddr, int len);
	int Acquire_Syscall(int index);
	int Release_Syscall(int index);
	int DestroyLock_Syscall(int index);
	void internal_fork(int pc);
	void Fork_Syscall(int pc, unsigned int vaddr, int len);
	void internal_exec(int pc);
	void Exec_Syscall(unsigned int vaddr, int len);
	void Yield_Syscall();
	void Exit_Syscall(int status);
	int Rand_Syscall(int range, int offset);
	void Printf_Syscall(unsigned int vaddr, int len, int num1);


	vi. Functions modified and in which file.
	In addrspace.cc:
	AddrSpace::AddrSpace(OpenFile* executable) : fileTable(MaxOpenFiles);
	AddrSpace::InitRegisters();

	In exception.cc:
	void ExceptionHandler(ExceptionType which);

	In progtest.cc
	void StartProcess(char* filename);




V. TESTING
	Part 1:
	For testing locks and cvs, please run "nachos -x ../test/lock_cv_test*" (* indicating which test number it is) in the userprog folder.  Most of tests are taken from the testsuite in project 1.  There are some additional tests to test destroy, index access, and several initializations of variables.  Here is a description of the different tests:
		Test 1: 
		First thread will acquire and release lock.
		Second thread will try to release the lock without acquiring first, in doing so will throw an error.
		Third thread will try to acquire a lock after it's been destroyed.  This will also throw an error.
		Fourth thread will acquire a lock, destroy it, and acquire it again to show that it has not been destroyed yet.  Then the thread will release the lock, which will destroy it.  The thread will then try to acquire the lock after it's been destroyed which will throw an error.
		The fifth thread will create two locks in a row and acquire them.  It will also access an index of -1 for acquire and release which will throw errors.
		Test 2:
		The first thread will signal a cv with nothing waiting.  This will throw an error
		The second thread will wait without a signal.
		The third thread will signal the waiting thread from thread 2.
		The fourth thread will destroy the cv.  It will the signal the cv, which will throw an error.
		The fifth thread will create 2 cvs and also pass in indices of -1 to wait, signal, and broadcast which will throw errors.
		Test 3:
		Test 3 will start 5 waiter threads that will wait.  It will then start a signaller thread that will signal the waiter threads.  Only one waiter will be released.
		Test 4:
		Test 4 will start 5 waiter threads that will wait.  It will then start a signaller thread that will broadcast the waiter threads.  All waiter threads will be released.
		Test 5: 
		The first thread will wait on a condition under lock1.
		The second thread will signal a condition under lock2.  This will throw an error stating that the waiting lock is different from the lock passed in.


	Part 2:
		Testing fork and exec:
			To test Fork and Exec, run command: nachos -x ../test/testexit
			This forks three threads from the testexit process, t1, t2 and t3, and executes 2 new processes that each fork 3 threads, g1, g2 and g3. A write statement should print out for each fork in all 3 processes and 2 printouts from the main of the 2 new executed processes. If all printouts are there, it works! If exit works properly, the program should be halted when the second g3 is printed. This means the last thread in the last executing process has been finished, so the program should halt and all memory will be reclaimed. 
		

	Part 3:
	For testing purposes, please run "nachos -x ../test/passporttest*" (* indicating which test number it is).  From there you can select tests 1 - 7 or the full simulation.  Each test will run with a set number of customers, clerks, and cashiers which will be printed out at the beginning of the test.
	Each test will print out the print statements outlined in the output statement guidelines as well as any releveant "TEST_X:" statements (X being the test number).

	Disclaimer: Not all tests will say "Test X PASSED".  Depending on the test it may be required to view the print statements and read the below documentation to verify the test has passed.

	TEST_1: Customers always take the shortest line, but no 2 customers ever choose the same shortest line at the same time
	-Based on the output guidelines you can see that Customer 0 enters line 0 because there are no customers in either line.  Customer 1 goes into line 1 because line 0 already has Customer 0 in it.  Customer 2 goes into line 0 because there is a customer in each line and Customer 3 goes into line 1 because line 0 has 2 customers and line 1 only has one.
	-The "TEST_1:" statements show that the Customers enter the line at different times because the lock for Customer 2 is acquired after Customer 1 has gotten in line.
	See: 
		TEST_1: Customer 0 has acquired ApplicationClerk's line lock
		Customer 0 has gotten in regular line for ApplicationClerk 0
		TEST_1: Customer 1 has acquired ApplicationClerk's line lock
		Customer 1 has gotten in regular line for ApplicationClerk 1
		TEST_1: Customer 2 has acquired ApplicationClerk's line lock
		Customer 2 has gotten in regular line for ApplicationClerk 0
		TEST_1: Customer 3 has acquired ApplicationClerk's line lock
		Customer 3 has gotten in regular line for ApplicationClerk 1
		TEST_1: Customer 4 has acquired ApplicationClerk's line lock
		Customer 4 has gotten in regular line for ApplicationClerk 0

	TEST_2: Managers only read one from one Clerk's total money received, at a time
	Test 2 has 2 customers and 1 of each of the clerks, the customers will go through all the clerks and complete their processes of getting their passport, paying 100$ each to the cashier. Throughout this time the manager will look around and print out the amount of money held by the various clerks. By the end, the manager should print out the correct amount from the cashiers.
	See:
		Manager has counted a total of 0 for Application Clerks
		Manager has counted a total of 0 for Picture Clerks
		Manager has counted a total of 0 for Passport Clerks
		Manager has counted a total of 100 for Cashiers
		Manager has counted a total of 100 for the Passport Office

		The above is a demonstration of what the very last check by the managers should print out

	TEST_3: Customers do not leave until they are given their passport by the Cashier. 
	The Cashier does not start on another customer until they know that the last 
	Customer has left their area
	-There are 3 Customers and 1 Cashier.  The print statements of the output guidelines should give indication of whether the test passes or not.
	See: 
		...
		Cashier_0 has provided Customer_0 their completed passport
		Cashier_0 has recoreded that Customer_0 has been given their completed passport
		Customer 0 is leaving the Passport Office
		Cashier 0 has signalled a customer to come to their counter
		Customer_1 has given SSN 1 to Cashier_0
		...
	As the test requires: "Customer 0 is leaving the Passport Office" comes after "Cashier 0 has recorded that Customer 0 has been given their completed passport".  Only when the Customer has left the passport office does the "Cashier 0 signal a Customer to come to their counter"

	TEST_4: Clerks go on break when they have no one waiting in their line
	- There are 1 AppClerks and 1 Customers, thus the moment the test begins the AppClerk should go on break immediately. The manager will wake up that customer and allow the application clerk to process that customer. Then when the customer moves on the app clerk should immediately go back on break because there are no more customers in line.
	See:
		...
		Customer 0 has gotten in regular line for ApplicationClerk 0
		Manager has woken up ApplicationClerk 0
		ApplicationClerk 0 is coming off break
		ApplicationClerk 0 has signalled a Customer to come to their counter
		Customer 0 has given SSN 0 to ApplicationClerk 0
		ApplicationClerk 0 has received SSN 0 from Customer 0
		ApplicationClerk 0 has recorded a completed application for Customer 0
		ApplicationClerk 0 is going on break
		...



	TEST_5: Managers get Clerks off their break when lines get too long
	There will be 3 customers and 1 application clerk. The clerk will go break the moment they are initialized because there are no customers are in line. Then 3 customers will enter the line and the application clerk will wake up and process all the customers.
	See:
		ApplicationClerk 0 is going on break
		Customer 0 has gotten in regular line for ApplicationClerk 0
		Customer 1 has gotten in regular line for ApplicationClerk 0
		Customer 2 has gotten in regular line for ApplicationClerk 0
		Manager has woken up ApplicationClerk 0
		...

	TEST_6: Total sales never suffers from a race condition
	-There are 20 Customers and 2 of each type of Clerk and Cashier.  Each Clerk has a global BribeMoney variable and the cashier has a global Money variable.  The printout statements will illustrate that a lock is acquired everytime a transaction occurs and released after the transaction.  Since a lock is being used during this time, only one clerk/cashier cannot update the global money variable at a time.  The total sales is calculated by adding the three BribeMoney variables and the cashier's Money variable.  Since the manager is the only thread that will be adding these variables up, it will not suffer from outside manipulation.  I also increased the probability that a customer would bribe a clerk/cashier from 30% to 60% in order to demonstrate the test results.
	See:
	BribeMoney
		TEST_6: PictureClerk 1 acquired their line lock
		PictureClerk 1 has received $500 from Customer 17
		PictureClerk 0 has received SSN 2 from customer 2
	Cashier
		TEST_6: Cashier 0 acquired their line lock
		Cashier 0 has signalled customer to come to their counter
		Customer_1 has given Cashier_6 $100
	Total
		Manager has has counted a total of 0 for Application Clerks 
		Manager has has counted a total of 2500 for Picture Clerks 
		Manager has has counted a total of 2500 for Passport Clerks 
		Manager has has counted a total of 5000 for Cashiers 
		Manager has has counted a total of 10000 for the Passport Office 


	TEST_7:
	--
		Not fully implemented




VI. DISCUSSION: 

	i. Experiment expectation 
	Syscalls written in exception.cc should allow full simulation from project 1 to run correctly using -rs values and with various numbers of customers and clerks. All tests from project 1 should be converted to C and be run with the same output print statements that were run in project 1.
	ii. Experiment result
	Full simulation, locks/cv tests and full simulation tests all work correctly. Only thing that is missing is senator right now as we didn't implement that in project 1. 

	
	

VII. MISCELLANEOUS 
	
		
	
