Title:  Writeup for Project 4, Fall 2015 CSCI 350
 Date:  12/03/2015
 Group:
 Anjali Ahuja   ahujaa@usc.edu
 Anne Kao     annekao@usc.edu
 Bernard Xie  bernardx@usc.edu


I. REQUIREMENTS:
  + Part 1: 
  Implement all the entities from the Passport Office Simulation so that it uses Nachos clients. All client messages should go to a Nachos server. The server connect the clients and the user programs.

  + Part 2:
  The server code can have from 1 to 5 servers working together in a group. Each server can receive a request from any client. In fact, the client Nachos kernels are to randomly generate a server machine ID for each request message they send.
  
  Each server is to only have the locks/CVs/MVs in their table that they create. This means that no server will have a complete set of locks/CVs/MVs. Only all the servers together have all the locks/CVs/MVs.

  When a server receives a request message from a client, it will first check its locks/CVs/MVs tables like in project 3 part 3. However, if the object is not found in the table, it no longer means it does not exist. It may have been created by one of the other servers.

  Thus, when a server does not find an object in its tables, it must send a server request message to all the other servers. Each server, upon receiving a server request message, must look in their tables to see if they have the requested object. Each server must reply to the requesting server 'yes', or 'no'.

II. ASSUMPTIONS:

  
III. DESIGN:
  i. Part 1
    Converting passport code into multiple different files each specific type of clerk, cashier, customer, and manager are all their own client.  Setup.h is used in order to create and set relevant locks, cvs, and mvs.

    For MVs for each clerk and customer, there would be an MV that held each clerk/customer's mv value.  The clerk itself would have values that represented specific variables we used for prior implementations such as ID, State, Lock, CV, LineCV, LineCount, BribeLineCV, BribeLineCount, CurrentCust, and LikePicture.  Customer had SSN, Money, and SendToBack.

  ii. Part 2
    Since we have multiple servers, server implementation becomes quite different. When the server receives a request from a client, it will first check whether or not it owns the relevant structures being called. If not, then it will send a message out to all the other servers to see who does. Those servers will respond with either a true, in which it does, or a false, in which it doesn't. To separate the servers from part1, we made it so that you have to run -server2  for part2 of the project. Based on different RPCs, it interprets that differently:

    Create_Lock, Create_CV, Create_MV:
    - For create, the server gets the request from the client, if that server doesn't have the particular object, then it will send a message to the other servers asking if they have it. If they don't have it, then they send messages back to the original server who requested the create. That server has a requestTable which tracks the results it receives from the other servers, if they all reply with false (indicating they don't work the particular object), then the original server will create the object and send it back to the client.

    Acquire, Release, Get, Set, Destroy_Lock, Destroy_CV, Destroy_MV
    - For these RPCs, the client will request to one of the servers, if that server owns the object, then it will execute the particular RPC on that object and return a message to the client indicating its success. Otherwise it'll send a message to all the servers, and the particular server that owns that object will execute the RPC and return a message to the client. If none of the servers are able to find the object(s) then the original server will respond to the client with an error.

    Wait, Signal, Broadcast
    - These RPCs are more complex as they test different cases of when a lock or cv exists on a server. Wait and signal handle the cases if the lock and cv are both on the same server, if the lock exists but not the cv, if the cv exists but not the lock, or if neither exist. They also handle error cases if the server doesn’t actually own the lock or the cv being singled doesn’t belong to the correct lock. 




 
IV. IMPLEMENTATION

  i. Files Modified
  WRITEUP
  ../code/machine/machine.h
  ../code/userprog/exception.cc
  ../code/threads/system.h
  ../code/network/nettest.cc
  ../test/Makefile


  ii. Files added
  ../test/AppClerk.c
  ../test/PicClerk.c
  ../test/PassportClerk.c
  ../test/Cashier.c
  ../test/Manager.c
  ../test/Setup.h


  iii. Data Structures added, file they were added to    
  In ../code/network/nettest.cc
  struct ServerRequest;

  iv. Data structures modified and file they were added to
  In ../code/userprog/addrspace.h
    TranslationEntry *pageTable --> PageTable *pageTable

  v. Functions added and in which file

  In ../code/nettest.cc
  void sendReplyToServer;
  void sendReplyToClient;
  void CreateServerRequest;
  bool validChecks;

  In ../test/Setup.h
  void initGlobalData;
  void initCustomers;
  void initAppClerks;
  void initPicClerks;
  void initPassportClerks;
  void initCashiers;

  In ../test/AppClerk
  void startAppClerk;

  In ../test/PicClerk
  void startPicClerk;

  In ../test/PassportClerk
  void startPassportClerk;

  In ../test/Cashier
  void startCashier;

  In ../test/Manager
  void startManager;

  In ../test/Customer
  void startCustomer;
    
  vi. Functions modified and in which file.
  In ../code/userprog/exception.cc
  void SyscallSendMsg(std::string request) 

  In ../code/network/nettest.cc
  void Server;
  void Server2;

    

V. TESTING (For parts that work)
  Part1
  We demonstrate that Part 1's code translation works with 1 server.  Please note it's important to change NUM_SERVERS in System.h on line 47 to 1 or there will be an error.
  Currently, our Passport Simulation works partway through with only 1 of each type of person.
    run "nacho -m 0 -server"
        "nacho -m 1 -x ../test/AppClerk"
        "nacho -m 2 -x ../test/PicClerk"
        "nacho -m 3 -x ../test/PassportClerK"
        "nacho -m 4 -x ../test/Cashier"
        "nacho -m 5 -x ../test/Customer"
        "nacho -m 6 -x ../test/Manager"
  As you can see from the output, Customer will complete his application for the AppClerk and there will be an error thrown for an invalid Signal when trying to signal the PicClerk with their SSN.  The cause of this is unknown at the moment.  We can also see that the manager will wake up any on break clerks when there is a customer.

  When running with more than two customers (run "nacho -m 5 -x ../test/Customers" instead) our program throws all sorts of errors.  The root cause of this is when we call GetMV on a variable customers in order to set our customers, for some reason it returns the incorrect value (returns a 7 which is the picClerks mv value).  After extensive debugging, we're not sure why this occurs as when we set the variable, everytime it is the correct number (5).

  Part2:
  Tests for locks and cvs:

  In system.h we can set the number of servers we'll have based on NUM_SERVERS
  for n servers: 
    run "nachos -m 0 -server2”
    run "nachos -m 1 -server2”
    ...
    run "nachos -m n -server2”

    in different terminal windows

  Test 1:
  This test shows that the first instance will acquire the lock.  (if the servers number is 5)
    see: Test 1 acquiring lock
         Test 1 acquires lock
  Each instance after will only say "Test 1 acquiring lock" because it is waiting on the lock to be released from the first instance.  When that happens, it will then say "Test 1 acquires lock".  
  terminal 1: run "nachos -m 5 -x ../test/lock_cv_test1"
  terminal 2: run "nachos -m 6 -x ../test/lock_cv_test1"
  terminal 3: run "nachos -m 7 -x ../test/lock_cv_test1"
  terminal 4: run "nachos -m 8 -x ../test/lock_cv_test1"
  terminal 5: run "nachos -m 9 -x ../test/lock_cv_test1"

  Test 2:
  This test demonstrates the wait, signal, and broadcast.  The first two instances will wait.  The third instance will signal, which will wake up the first waiting instance.  After that we have a fourth instance wait and the fifth instance will broadcast, waking up the second and fourth clients.
  terminal 1: run "nachos -m 5 -x ../test/lock_cv_test2"
  terminal 2: run "nachos -m 6 -x ../test/lock_cv_test2"
  terminal 3: run "nachos -m 7 -x ../test/lock_cv_test3"
  terminal 4: run "nachos -m 8 -x ../test/lock_cv_test2"
  terminal 5: run "nachos -m 9 -x ../test/lock_cv_test4"

  Test 3:
  This test demonstrates the destroying of a lock and cv.  The first instance will create a lock and cv and destroy it.  The second instance will also create the same lock and cv and then try to Acquire the lock and wait on the cv.  This will throw an error.
  See: 
    Test 6 tries to acquire lock and wait on cv (both destroyed)
    Error in acquiring lock
    Error in waiting cv
  terminal 1: run "nachos -m 5 -x ../test/lock_cv_test5"
  terminal 2: run "nachos -m 6 -x ../test/lock_cv_test6"


  Test 4: MV Tests
  This test demonstrates the RPC calls for monitor  variables that were created for this project (Create, get, set destroy). The first 4 instances of nachos will get an MV value, increment it and wait. The 5th instance will set a new value to the MV and broadcast the other 4 instances. After the instances are broadcasted, the new value of the monitor variable is printed and locks are released. 
  terminal2: run "nachos -m 5 -x ../test/MVtests"
  terminal3: run "nachos -m 6 -x ../test/MVtests"
  terminal4: run "nachos -m 7 -x ../test/MVtests"
  terminal5: run "nachos -m 8 -x ../test/MVtests"
  terminal6: run "nachos -m 9 -x ../test/MVtests1"


VI. DISCUSSION: 
  i. Experiment expectation 
  We expect the passport office and all our tests to be running completely.

  ii. Experiment result
  The passport office does not run fully, and only some of our tests work for part2.

  iii. Explanation (Explain how your project proves what its supposed to prove)
  For part 1.
    - As explained in testing, our Passport simulation code only partially works with one server.  Since we ran into issues with part 2, it was difficult to fully debug our passport simulation code.

  For part 2.
    - Create_Lock, Destroy_Lock, Create_MV, Destroy_MV, Create_CV, Destroy_CV, Get, Set all fully work (as indicated by our tests)
    - Acquire, Release, Wait, Signal, Broadcast work partially
      - When running on two servers, all our tests work correctly. However, for some reason when the lockID goes from Acquire and calls wait, the lock owner gets changed to -1 and we get a server error when trying to wait on the lock. In this case, the lock and cv are created on different servers and wait is handled by a different server trying to find the lock and cv. We could not figure out why this was happening, thus when running on more than 2 servers, our tests do not pass. 
  - Although these sys calls only work partially, our code handles each case in great detail to ensure that all cases of lock/cvs are handled properly. 

  

VII. MISCELLANEOUS 

  
